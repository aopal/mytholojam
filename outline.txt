game_list map[string]*Game;
move_list map[string]*Move

Class Game {
	player1_token string; // not shown in status calls
	player2_token string; // not shown in status calls
	game_name string;
  player1_equip map[string]*Equipment;
  player2_equip map[string]*Equipment;
  player1_spirits map[string]*Spirit;
  player1_spirits map[string]*Spirit;
  player1_nextaction *Action; // not shown in status calls
  player2_nextaction *Action; // not shown in status calls

  actionOrder []*Action; // nextactions are only appended here once both have been received by the server
  numActions int;
}

Class Equipment {
  id string;
  hp int;
  maxHp int
  atk int;
  def int;
  moves []*Move;
  inhabited boolean;
  inhabitedBy *Spirit;
}

Class Spirit {
  id string;
  hp int;
  maxHp int
  atk int;
  def int;
  speed int;
  moves []*Move;
  inhabiting *Equipment;
}
 
Class Move { // the swap move is unique
  name string;
  power int;
}

Interface Targetable {
  id string;
}

Class Action {
  user *Spirit;
  target *Targetable; // either a spirit or equipment
  move *Move; // name of attacking move, or the special 'swap' move
}



routes
/create-game/game_name
  client sends desired name for game. server either responds with 200 and that player's token (a random string), or 400 if a game of that name exists
/join-game/game_name
  client sends name of game to join. Server responds with 200 and that player's token (a random string) if that's a valid joinable game, or 400 otherwise
/status/game_name/action-counter
  Client sends name of game to get status of. Server responds with current state, i.e. both sides' parties, whether we're waiting on input, and any new actions taken. If the number of actions taken on the server is higher than what the client sent, the server also adds on an in-order list of the new actions taken (only for animating/displaying what happened)
/action/game_name
  Client sends name of game to take action on. Payload is a json representation of what both spirits are doing, and the most recent action the client is aware of. Server responds with the output of a /status/ call, or rejects with 400 if the client is unaware of newer actions taken.

Other notes:
Thread/goroutine per game? Only one client's request, all of which are pretty fast to execute, is processed at one to ensure order.